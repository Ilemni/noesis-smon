from inc_noesis import *
from fmt_smon_pmm import load_pmm_data, pmm_check_signature, pmm_check_ciphered
from fmt_smon_plm import load_plm_animation
from fmt_smon_joker import load_joker, is_joker_chunk


# ----------
# DAT is a file format that contains the following data:
# 4 bytes size of header chunk
# The Header chunk (most data unknown, contains ciphered filename)
#
# 4 bytes size of PMM chunk
# The PMM chunk (skinned mesh), may be ciphered with a simple substitution cipher
#
# 4 bytes size of PLM chunk
# The PLM chunk (armature, animations)
#
# List of Joker chunks with in-game element IDs (diffuse and alpha texture)
# ----------


def registerNoesisTypes():
    handle = noesis.register("Summoners War Character", ".dat")
    noesis.setHandlerTypeCheck(handle, dat_check_type)
    noesis.setHandlerLoadModel(handle, dat_load_model)
    return 1


def dat_check_type(data):
    # Check type by skipping header chunk then checking PMM chunk signature
    if len(data) < 8:
        return 0
    bs = NoeBitStream(data)

    # Header size is usually 0x20 + len(filename_without_extension), sometimes with an extra byte
    # Part of the header contains the ciphered filename

    header_size = bs.readInt()
    if header_size < 32 or header_size > len(data) + 8:
        return 0

    # Check if PMM chunk signature is valid
    bs.seek(header_size + 8, NOESEEK_ABS)
    pmm = bs.readBytes(4)

    return pmm_check_signature(pmm, True)


def dat_load_model(data, models):
    noesis.logPopup()
    bs = NoeBitStream(data)

    # ================================= Header data= ================================= #

    header_size = bs.readUInt()
    header = DatHeader(bs, header_size)
    # print("[DAT:Header] Embedded header name: {0}".format(header.name))

    # =================================== PMM data =================================== #

    pmm_size = bs.readUInt()
    # print("[DAT:PMM] File Position: {0}, Size: {1}".format(hex(bs.tell()), hex(pmm_size)))

    # PMM signature: chunk may be ciphered, decipher if necessary
    pmm_signature = peek_bytes(bs, 4)

    if pmm_check_ciphered(pmm_signature):
        decipher_pmm(bs, pmm_size)

    pmm_data = load_pmm_data(bs)

    # =================================== PLM data =================================== #

    bs.seek(header_size + 4 + pmm_size + 4, NOESEEK_ABS)
    plm_size = bs.readInt()

    # print("[DAT:PLM] File Position: {0}, Size: {1}".format(hex(bs.tell()), hex(plm_size)))
    bones, animations = load_plm_animation(bs, pmm_data.scale_divider)

    # ================================= Texture data ================================= #

    bs.seek(header_size + 4 + pmm_size + 4 + plm_size + 4, NOESEEK_ABS)
    # print("[DAT:Tex] File Position: {0}".format(hex(bs.tell())))
    textures = []
    materials = []

    while not bs.checkEOF():
        # Some models may have only one image (special_mdl_*.dat)
        # And do not use a material_id system
        multi_material = True
        material_id = bs.readInt()
        if material_id > 255:
            multi_material = False
            chunk_size = material_id
            material_id = 0
        else:
            chunk_size = bs.readInt()
        if chunk_size == 0:
            continue

        if is_joker_chunk(bs):
            file_extension = ".jpg"
            diffuse_texture, alpha_texture = load_joker(bs)

            diffuse_texture.name = header.name + ("_" + material_names[material_id] if multi_material else "") + "_diffuse" + file_extension
            textures.append(diffuse_texture)

            if alpha_texture is not None:
                alpha_texture.name = header.name + ("_" + material_names[material_id] if multi_material else "") + "_alpha" + file_extension
                textures.append(alpha_texture)
        else:
            file_extension = ".png"

            diffuse_texture, alpha_texture = rapi.loadTexByHandler(bs.readBytes(chunk_size), file_extension), None

            diffuse_texture.name = header.name + ("_" + material_names[material_id] if multi_material else "") + file_extension
            textures.append(diffuse_texture)

        # print("[DAT:Tex:Material {0}] Size: {1} | Format: {2} | Has Alpha: {3}"
        #       .format(material_id, chunk_size, file_extension, alpha_texture is not None))
        material_name = "Material {0}".format(material_id) if multi_material else "Material"
        material = NoeMaterial(material_name, diffuse_texture.name)
        if alpha_texture is not None:
            material.setOpacityTexture(alpha_texture.name)

        materials.append(material)

        pmm_data.add_material(material.name)

    # ================================= Create model ================================= #

    model = pmm_data.construct_model()
    model.meshes[0].setName(header.name)
    model.setBones(bones)
    model.setAnims(animations)
    model.setModelMaterials(NoeModelMaterials(textures, materials))

    models.append(model)
    return 1


def decipher_pmm(bs, size):
    """
    :type bs: NoeBitStream
    :param bs: The bitstream containing the PMM chunk
    :type size: int
    :param size: The size of the PMM chunk to decipher
    """
    ciphered_pmm_chunk = peek_bytes(bs, size)

    deciphered = bytearray(size)
    for i in range(size):
        deciphered[i] = pmm_decipher[ciphered_pmm_chunk[i]]

    bs.writeBytes(deciphered)
    bs.seek(-size, NOESEEK_REL)


def peek_bytes(bs, length):
    """
    Reads bytes from the NoeBitStream without moving the stream position
    :type bs: NoeBitStream
    :type length: int
    :rtype: bytes
    """
    result = bs.readBytes(length)
    bs.seek(-length, NOESEEK_REL)
    return result


class DatHeader:
    def __init__(self, bs, header_len):
        start = bs.tell()
        # 0x11 bytes unknown, most identical across files
        bs.seek(0x11, NOESEEK_REL)

        # variable bytes original filename, todo: delimiter
        self.name = ""
        while True:
            c = filename_decipher[bs.readUByte()]
            if c == 0x00:
                break
            try:
                self.name += chr(c)
            except UnicodeDecodeError:
                break
        self.name = self.name.rstrip('\'')
        # variable bytes remaining header
        bs.seek(start + header_len, NOESEEK_ABS)


pmm_decipher = bytearray([
    0x2f, 0x7c, 0x47, 0x55, 0x32, 0x77, 0x9f, 0xfb, 0x5b, 0x86, 0xfe, 0xb6, 0x3e, 0x06, 0xf4, 0xc4,  # 00-0F
    0x2e, 0x08, 0x49, 0x11, 0x0e, 0xce, 0x84, 0xd3, 0x7b, 0x18, 0xa6, 0x5c, 0x71, 0x56, 0xe2, 0x3b,  # 10-1F
    0xfd, 0xb3, 0x2b, 0x97, 0x9d, 0xfc, 0xca, 0xba, 0x8e, 0x7e, 0x6f, 0x0f, 0xe8, 0xbb, 0xc7, 0xc2,  # 20-2F
    0xd9, 0xa4, 0xd2, 0xe0, 0xa5, 0x95, 0xee, 0xab, 0xf3, 0xe4, 0xcb, 0x63, 0x25, 0x70, 0x4e, 0x8d,  # 30-3F
    0x21, 0x37, 0x9a, 0xb0, 0xbc, 0xc6, 0x48, 0x3f, 0x23, 0x80, 0x20, 0x01, 0xd7, 0xf9, 0x5e, 0xec,  # 40-4F
    0x16, 0xd6, 0xd4, 0x1f, 0x51, 0x42, 0x6c, 0x10, 0x14, 0xb7, 0xcc, 0x82, 0x7f, 0x13, 0x02, 0x00,  # 50-5F
    0x72, 0xed, 0x90, 0x57, 0xc1, 0x2c, 0x5d, 0x28, 0x81, 0x1d, 0x38, 0x1a, 0xac, 0xad, 0x35, 0x78,  # 60-6F
    0xdc, 0x68, 0xb9, 0x8b, 0x6a, 0xe1, 0xc3, 0xe3, 0xdb, 0x6d, 0x04, 0x27, 0x9c, 0x64, 0x5a, 0x8f,  # 70-7F
    0x83, 0x0c, 0xd8, 0xa8, 0x1c, 0x89, 0xd5, 0x43, 0x74, 0x73, 0x4d, 0xae, 0xea, 0x31, 0x6e, 0x1e,  # 80-8F
    0x91, 0x1b, 0x59, 0xc9, 0xbd, 0xf7, 0x07, 0xe7, 0x8a, 0x05, 0x8c, 0x4c, 0xbe, 0xc5, 0xdf, 0xe5,  # 90-9F
    0xf5, 0x2d, 0x4b, 0x76, 0x66, 0xf2, 0x50, 0xd0, 0xb4, 0x85, 0xef, 0xb5, 0x3c, 0x7d, 0x3d, 0xe6,  # A0-AF
    0x9b, 0x03, 0x0d, 0x61, 0x33, 0xf1, 0x92, 0x53, 0xff, 0x96, 0x09, 0x67, 0x69, 0x44, 0xa3, 0x4a,  # B0-BF
    0xaf, 0x41, 0xda, 0x54, 0x46, 0xd1, 0xfa, 0xcd, 0x24, 0xaa, 0x88, 0xa7, 0x19, 0xde, 0x40, 0xeb,  # C0-CF
    0x94, 0x5f, 0x45, 0x65, 0xf0, 0xb8, 0x34, 0xdd, 0x0b, 0xb1, 0x29, 0xe9, 0x2a, 0x75, 0x87, 0x39,  # D0-DF
    0xcf, 0x79, 0x93, 0xa1, 0xb2, 0x30, 0x15, 0x7a, 0x52, 0x12, 0x62, 0x36, 0xbf, 0x22, 0x4f, 0xc0,  # E0-EF
    0xa2, 0x17, 0xc8, 0x99, 0x3a, 0x60, 0xa9, 0xa0, 0x58, 0xf6, 0x0a, 0x9e, 0xf8, 0x6b, 0x26, 0x98   # F0-FF
])

# Incomplete cipher, some letters/numbers have not been used
filename_decipher = bytearray([
    0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
    0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x6B, 0x00, 0x00, 0x00, 0x75, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x6D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x27, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x6A, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x73, 0x00, 0x77,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x72, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x67, 0x00, 0x00, 0x00, 0x6C,
    0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x78, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x00
])

material_names = {
    1: "water",
    2: "fire",
    3: "wind",
    4: "light",
    5: "dark",
    6: "pure"
}
